# [第四章 栈、队列、优先队列](#栈_队列_优先队列)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :---: | :---: | :---: | :---: | :---: |
| **第一节 栈** |  |  |  |  |
| [4-1 栈的基础应用 Valid Parentheses](#栈的基础应用) | [20](#20) | [150](#150)  | [735*](#735) | |
| [4-2 栈和递归的紧密关系 Binary Tree Preorder, Inorder and Postorder Traversal](#栈和递归的紧密关系) | [无] | [无] | | |
| [4-3 运用栈模拟递归](#运用栈模拟递归) | [144](#144) [94](#94) [145](#145) | [341*](#341) | [71*](#71) [388](#388) | |
| **第二节 队列** |  |  |  |  |
| [4-4 队列的典型应用 Binary Tree Level Order Traversal](#队列的典型应用) | [102](#102) [232](#232) | [107](#107) [103](#103) [199](#199) |  [637](#637) | |
| [4-5 BFS和图的最短路径 Perfect Squares](#BFS和图的最短路径) | [279](#279) | [127](#127) [126*](#126)  | [752](#752) | 675 |
| **第三节 优先队列** |  |  |  |  |
| [4-6 优先队列](#优先队列) | [无] | [无] | | |
| [4-7 优先队列相关的算法问题 Top K Frequent Elements](#优先队列相关的算法问题) | [347](#347) | [23](#23) | [692](#692) | 23 239 786 857 |
| [补充1：更多和栈相关的问题](#更多和栈相关的问题) | [无] | [无] | [133*](#133) [856](#856) [227](#227) [901](#901) | 224 282 772 |
| [补充2：更多和队列相关的问题](#更多和队列相关的问题) | [无] | [无] |  [622](#622) | |


# 栈_队列_优先队列
## 栈的基础应用
### 20
[20 Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/)

* 问题：

给定一个字符串，只包含(,){,},[,],判定字符串找那个的括号是否合法。

* 示例：

"()"、"()[]{}"是合法的

"(])"、"([)]])"就是非法的

* 解题：

利用栈的思路：

（1）是左方向的括号，就直接入栈

（2）右方向的括号，就拿出站定元素与之对比，匹配就弹出

```java
public boolean isValid(String s) {
    Stack<Character> stack=new Stack<>();
    for(int i=0;i<s.length();i++) {
        char c = s.charAt(i);
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.empty()) {
                return false;
            }

            char match;
            if (c == ')') {
                match = '(';
            } else if (c == '}') {
                match = '{';
            } else {
                assert c == ']';
                match = '[';
            }

            char topChar = stack.pop();
            if (topChar != match) {
                return false;
            }
        }
    }
    //注意有可能，这个栈放入的都是左方向的括号，此时直接返回 true是不对的
    if(!stack.empty()){
        return false;
    }
    return true;
}
```
### 150
[150 Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/description/)
```java
/**
* 问题描述：
根据逆波兰表示法，求表达式的值。
有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
  
* 说明：
整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

* 示例

示例 1：  
输入: ["2", "1", "+", "3", "*"]
输出: 9
解释: ((2 + 1) * 3) = 9

示例 2：  
输入: ["4", "13", "5", "/", "+"]
输出: 6
解释: (4 + (13 / 5)) = 6

示例 3：
输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
输出: 22
解释: 
((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
*/
//思路：
//1、典型的栈的应用问题
//2、准备一个栈存储数据，另一歌栈用来存储运算符
public int evalRPN(String[] tokens) {
    if(tokens.length == 1){
        //逆波兰式只有一个元素时，该元素必然是整数
        return Integer.parseInt(tokens[0]);
    }
    Stack<Integer> numbers = new Stack<>();

    for(String token : tokens){
        if("+".equals(token)){
            int number1 = numbers.pop();
            int number2 = numbers.pop();
            numbers.push(number2 + number1);
        }else if("-".equals(token)){
            int number1 = numbers.pop();
            int number2 = numbers.pop();
            numbers.push(number2 - number1);
        }else if("*".equals(token)){
            int number1 = numbers.pop();
            int number2 = numbers.pop();
            numbers.push(number2 *number1);
        }else if("/".equals(token)){
            int number1 = numbers.pop();
            int number2 = numbers.pop();
            numbers.push(number2 / number1);
        }else{
            // token字符表示的是数字
            int num = Integer.parseInt(token);
            numbers.push(num);
        }
    }
    return numbers.pop();
}
```

```java
//改进：思路相同使用 case 进行改进
public int evalRPN(String[] tokens) {
    if(tokens.length == 1){
        //逆波兰式只有一个元素时，该元素必然是整数
        return Integer.parseInt(tokens[0]);
    }
    Stack<Integer> numbers = new Stack<>();

    //number1,number2 记录弹出的栈顶元素
    int number1,number2;
    for(String token : tokens){
        switch (token){
            case "+":
                number1 = numbers.pop();
                number2 = numbers.pop();
                numbers.push(number2 + number1);
                break;
            case "-":
                number1 = numbers.pop();
                number2 = numbers.pop();
                numbers.push(number2 - number1);
                break;
            case "*":
                number1 = numbers.pop();
                number2 = numbers.pop();
                numbers.push(number2 * number1);
                break;
            case "/":
                number1 = numbers.pop();
                number2 = numbers.pop();
                numbers.push(number2 / number1);
                break;
            default:
                // token字符表示的是数字
                int num = Integer.parseInt(token);
                numbers.push(num);
        }
    }
    return numbers.pop();
}
```

### 735
[735 Asteroid Collision](https://leetcode.com/problems/asteroid-collision/)
```java
/**
* 问题描述：

给定一个整数数组 asteroids，表示在同一行的行星。
对于数组中的每一个元素，其绝对值表示行星的大小，
正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。
找出碰撞后剩下的所有行星。
碰撞规则：
两个行星相互碰撞，较小的行星会爆炸。
如果两颗行星大小相同，则两颗行星都会爆炸。
两颗移动方向相同的行星，永远不会发生碰撞。
 
* 示例：

示例 1:
输入: 
asteroids = [5, 10, -5]
输出: [5, 10]
解释: 
10 和 -5 碰撞后只剩下 10。 5 和 10 永远不会发生碰撞。

示例 2:
输入: 
asteroids = [8, -8]
输出: []
解释: 
8 和 -8 碰撞后，两者都发生爆炸。

示例 3:
输入: 
asteroids = [10, 2, -5]
输出: [10]
解释: 
2 和 -5 发生碰撞后剩下 -5。10 和 -5 发生碰撞后剩下 10。

示例 4:
输入: 
asteroids = [-2, -1, 1, 2]
输出: [-2, -1, 1, 2]
解释: 
-2 和 -1 向左移动，而 1 和 2 向右移动。
由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。
*/
//思路：
//1、这里发生碰撞的行星都是相邻的，行星是使用数组表示的，我们看当前行星是否发生碰撞，一定要看其相邻的两个行星，
//这里借助stack存储不会发生相撞的行星，因为栈顶元素就是离当前行星最近的行星。
//2、当asteroids为正数时，不管栈顶元素正负，都可以直接push。
//（若栈顶元素为负，栈中行星向左运动，输入的asteroids[i]为正数，栈外星体向右运动，不会碰撞）
//3、当asteroids为负数时，
//若栈顶元素为负，直接push(方向相同不会撞击)
//若栈顶元素为正，考虑具体撞击问题，有可能撞击之后，还会发生撞击，比如 10 5 -10 ，-10与5撞击后变成-10，还会以10撞击 
public int[] asteroidCollision(int[] asteroids) {
    if(asteroids == null || asteroids.length ==1){
        return asteroids;
    }

    Stack<Integer> stack = new Stack<>();

    for(int asteroid : asteroids){
        //判断当前行星是否会“粉身碎骨”，默认false,表示不会
        boolean isCollision = false;

        if (stack.isEmpty()){
            stack.push(asteroid);
            continue;
        }
        if(asteroid > 0){
            stack.push(asteroid);
        }else{ // 这里就对应 < 0 的情况
            if(stack.peek() < 0){  // 两个行星方向相同
                stack.push(asteroid);
            }else{ //两个行星方向不同，此时必然发生碰撞:这时候，我们注意哪个行星能留下；或者这两个行星都消失
                while(!stack.isEmpty() && stack.peek()>0){
                    //!stack.isEmpty() && stack.peek()>0 会一直发生碰撞
                    if(Math.abs(asteroid) < Math.abs(stack.peek())){
                        isCollision = true;//当前行星“粉身碎骨”
                        break;
                    }else if(Math.abs(asteroid) == Math.abs(stack.peek())){
                        //两个行星都消失了
                        isCollision = true; //当前行星“粉身碎骨”
                        stack.pop(); //栈顶元素出栈（相当于栈顶元素“粉身碎骨”了）
                        break;
                    }else{
                        //栈顶元素出栈即可（相当于栈顶元素“粉身碎骨”了）
                        stack.pop();
                    }
                }
                if(isCollision == false){
                    stack.push(asteroid);
                }
            }
        }
    }

    int[] res = new int[stack.size()];
    int index = stack.size() - 1;
    //注意 : stack出栈是逆序的
    while(!stack.isEmpty()){
        res[index--] = stack.pop();
    }
    return res;
}
```

## 栈和递归的紧密关系

1. 栈模拟系统栈: 将要访问1节点，Stack中分为3个命令: 

```html
[cout-1] [go 1-L] [go 1-R] (红色表示未执行)
```

<div align="center"><img src="pics//stackQueue//stack_13.png"/></div>

2. 访问1节点，输出1(树中节点1变成蓝色)，并且访问了1节点的左孩子节点，Stack中命令：

```html
[cout-1](蓝) [go 1-L](蓝) [go 1-R] (红色表示未执行，蓝色表示已执行)
```
  
<div align="center"><img src="pics//stackQueue//stack_14.png"/></div>

3. 访问2节点，输出2(树中节点2变成蓝色)，并且访问了2节点的左孩子节点，Stack中命令：

```html
[cout-2](蓝) [go 2-L](蓝) [go 2-R]
[cout-1](蓝) [go 1-L](蓝) [go 1-R]
```

<div align="center"><img src="pics//stackQueue//stack_15.png"/></div>

4. 访问2节点的左孩子，结束，此时需要返回到2节点原先的状态，栈顶元素出栈 

```html
[cout-2](蓝) [go 2-L](蓝) [go 2-R] (出栈)
[cout-1](蓝) [go 1-L](蓝) [go 1-R]
```
<div align="center"><img src="pics//stackQueue//stack_16.png"/></div>

5. 栈顶元素出栈，访问2的右孩子

<div align="center"><img src="pics//stackQueue//stack_17.png"/></div>

6. 访问2节点的右孩子，结束，此时需要返回到系统状态，栈顶元素出栈 
<div align="center"><img src="pics//stackQueue//stack_18.png"/></div>

7. 1节点左孩子，结束，此时需要返回到系统状态，栈顶元素出栈

<div align="center"><img src="pics//stackQueue//stack_19.png"/></div>

8. 访问1节点的右孩子类似

<div align="center"><img src="pics//stackQueue//stack_20.png"/></div>

## 运用栈模拟递归

### 144
[144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)

* 解题：

使用栈模拟系统栈，解决前序遍历的问题。

（1）将头结点压入栈中，对栈进行初始化，go-1表示访问1结点

<div align="center"><img src="pics//stackQueue//stack_1.png"/></div>

（2）由于先序遍历，根据栈的特性，先访问1的右子节点，再访问1的左子节点，最后访问1结点

<div align="center"><img src="pics//stackQueue//stack_2.png"/></div>

（3）1结点是栈顶元素，由于命令是cout，cout 1出栈，所以直接输出节点值1

<div align="center"><img src="pics//stackQueue//stack_3.png"/></div>

（4）此时go 1-L是栈顶元素,就访问1结点的左孩子节点，也就是节点2

<div align="center"><img src="pics//stackQueue//stack_4.png"/></div>

（5）这时候访问结点2，再访问2的右子树的根节点和2的左子树的根节点，最后再访问2节点

<div align="center"><img src="pics//stackQueue//stack_5.png"/></div>

（6）栈顶是 cout-2，输出结果后，栈顶元素是 go-2-L==null,go-2-R==null，do nothing

<div align="center"><img src="pics//stackQueue//stack_6.png"/></div>

(7)访问到3结点

<div align="center"><img src="pics//stackQueue//stack_7.png"/></div>

（8）最终栈为空

```java
private enum Command{GO,PRINT};

private class StackNode{
    Command command;
    TreeNode node;
    StackNode(Command command,TreeNode node){
        this.command=command;
        this.node=node;
    }
}

public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }
    Stack<StackNode> stack=new Stack<>();
    stack.push(new StackNode(Command.GO,root));
    while(!stack.empty()){
        StackNode stackNode=stack.pop();
        Command command=stackNode.command;
        if(command==Command.PRINT){
            ret.add(stackNode.node.val);
        }else{
            if(stackNode.node.right!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.right));
            }
            if(stackNode.node.left!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.left));
            }
            stack.push(new StackNode(Command.PRINT,stackNode.node));
        }
    }
    return ret;
}
```
### 94
[94 Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)
```java
private enum Command{GO,PRINT};

private class StackNode{
    Command command;
    TreeNode node;
    StackNode(Command command, TreeNode node){
        this.command=command;
        this.node=node;
    }
}

public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }

    Stack<StackNode> stack=new Stack<>();
    stack.push(new StackNode(Command.GO,root));
    while(!stack.empty()){
        StackNode stackNode=stack.pop();
        Command command=stackNode.command;
        if(command==Command.PRINT){
            ret.add(stackNode.node.val);
        }else{
            if(stackNode.node.right!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.right));
            }
            stack.push(new StackNode(Command.PRINT,stackNode.node));
            if(stackNode.node.left!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.left));
            }
        }
    }
    return ret;
}
```
### 145
[145 Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)
```java
private enum Command{GO,PRINT};

private class StackNode{
    Command command;
    TreeNode node;
    StackNode(Command command,TreeNode node){
        this.command=command;
        this.node=node;
    }
}

public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }
    Stack<StackNode> stack=new Stack<>();
    stack.push(new StackNode(Command.GO,root));
    while(!stack.empty()){
        StackNode stackNode=stack.pop();
        Command command=stackNode.command;
        if(command==Command.PRINT){
            ret.add(stackNode.node.val);
        }else{
            stack.push(new StackNode(Command.PRINT,stackNode.node));
            if(stackNode.node.right!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.right));
            }
            if(stackNode.node.left!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.left));
            }
        }
    }
    return ret;
}
```

### 341
[341 Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/description/)
```java
/**
* 问题描述：
给定一个嵌套的整型列表。设计一个迭代器，
使其能够遍历这个整型列表中的所有整数。
列表中的项或者为一个整数，或者是另一个列表。

* 示例：
示例 1:
输入: [[1,1],2,[1,1]]
输出: [1,1,2,1,1]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,1,2,1,1]。

示例 2:
输入: [1,[4,[6]]]
输出: [1,4,6]
解释: 通过重复调用 next 直到 hasNext 返回false，next 返回的元素的顺序应该是: [1,4,6]。
*/
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return null if this NestedInteger holds a single integer
 *     public List<NestedInteger> getList();
 * }
 */
//思路：
//1、用栈的目的是可以模拟递归, 也就是可以
//TODO：层层嵌套, 最深的总是在最上面, 当遍历完深层的数组还可以回来继续遍历之前的层。
//2、调用next函数之前，要求hasNext()返回true,此时栈顶元素一定是Interger类型
//3、hasNext():判断栈顶元素是否是Integer类型，
// 是 返回 true
// 否 再将列表中数据放入栈中，循环判断
public class NestedIterator implements Iterator<Integer> {
    //使用栈模拟递归
    private Stack<NestedInteger> stack;

    public NestedIterator(List<NestedInteger> nestedList) {
        stack = new Stack<>();
        //初始化栈中元素，为了出栈顺序，我们将列表中元素倒序存入stack
        for(int i=nestedList.size()-1;i>=0;i--){
            stack.push(nestedList.get(i));
        }
    }

    @Override
    public Integer next() {
        //调用next之前，要求hasNext()返回true,此时栈顶元素一定是Interger类型
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        //判断是否有后一个元素
        while(!stack.isEmpty()){
            if(stack.peek().isInteger()){ //栈顶元素是整数，说明有下一个元素是整数，直接返回true
                return true;
            }else{ //说明栈顶元素是list,将list转换为一列整数，再放入stack中(注意放入顺序)
                List<NestedInteger> tmpNestedList = stack.pop().getList();
                //逆序放入，出栈时才会顺序
                for(int i=tmpNestedList.size()-1;i>=0;i--){
                    stack.push(tmpNestedList.get(i));
                }
            }
        }
        return false;
    }
}
```

### 71
[71 Simplify Path](https://leetcode.com/problems/simplify-path/description/)
```java
/**
* 问题描述：

以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。
在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；
此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；
两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径
  
请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。
最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。
  
* 示例：   
  
示例 1：  
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。

示例 2：
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。

示例 3：
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。

示例 4：
输入："/a/./b/../../c/"
输出："/c"

示例 5：
输入："/a/../../b/../c//.//"
输出："/c"

示例 6：
输入："/a//b////c/d//././/.."
输出："/a/b/c"
*/
/**
 * 思路：
 * 字符串处理，由于".."是返回上级目录（如果是根目录则不处理），因此可以考虑用栈记录路径名，以便于处理。
 * 需要注意几个细节：
 *1、何时出栈？
 * "../ "代表回上一级目录，那么把栈定元素出栈
 *
 * 2、何时
 * 如果遇到不是 "."，也不是""，不是".."，那么进栈
 * "" 针对的是 // 这种情况。
 */
// 思路：
//1、目录之间是使用 "/" 进行分割的，我们这里要简化路径，实际上就是要简化目录
//2、"../" 表示上一级目录，比如"/../"，实际上就是"/" ,要记录原来位置信息，所以我们使用栈来记录目录信息
public String simplifyPath(String path) {
    if(path==null || "/".equals(path)){
        return path;
    }

    //记录所访问的目录
    //注意：
    //1、遇到 .. 就说明是上一级目录，栈顶的目录就要出栈
    //2、如果遇到不是 "."，也不是""( "" 针对的是 // 这种情况)，不是".."，那么进栈。
    Stack<String> stack = new Stack<>();

    //获取目录数组
    String[] folders = path.split("/");
    for(String dir : folders){
        if(!stack.empty() && "..".equals(dir)){
            //TODO:出栈一定要保证栈是非空的
            stack.pop();
        }
        if(! "..".equals(dir) && !"".equals(dir) && !".".equals(dir)){
            stack.push(dir);
        }
    }
    return "/"+String.join("/",stack);
}
```

### 388
[388 Longest Absolute File Path](https://leetcode.com/problems/longest-absolute-file-path/)
```java
/**
* 问题描述：

假设我们以下述方式将我们的文件系统抽象成一个字符串:
字符串 "dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext" 表示:

dir
  subdir1
  subdir2
      file.ext
目录 dir 包含一个空的子目录 subdir1 和一个包含一个文件 file.ext 的子目录 subdir2 。

字符串 "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext" 表示:

dir
  subdir1
      file1.ext
      subsubdir1
  subdir2
      subsubdir2
          file2.ext
目录 dir 包含两个子目录 subdir1 和 subdir2。 
subdir1 包含一个文件 file1.ext 和一个空的二级子目录 subsubdir1。
subdir2 包含一个二级子目录 subsubdir2 ，其中包含一个文件 file2.ext。

我们致力于寻找我们文件系统中文件的最长 (按字符的数量统计) 绝对路径。
例如，在上述的第二个例子中，最长路径为 "dir/subdir2/subsubdir2/file2.ext"，
其长度为 32 (不包含双引号)。

给定一个以上述格式表示文件系统的字符串，返回文件系统中文件的最长绝对路径的长度。
如果系统中没有文件，返回 0。

* 说明:

文件名至少存在一个 . 和一个扩展名。
目录或者子目录的名字不能包含 .。
要求时间复杂度为 O(n) ，其中 n 是输入字符串的大小。

请注意，如果存在路径 aaaaaaaaaaaaaaaaaaaaa/sth.png 的话，
那么  a/aa/aaa/file1.txt 就不是一个最长的路径。
*/
//思路：
//1、字符串中包括 \n和\t 转义字符
// \n(换行符)：分割文件(目录和文件)
// \t(水平制表符)：\t个数表示该文件所在的层次
//2、我们可以用哈希表来建立<文件层次，当前层次的绝对路径长度>之间的映射，
//TODO：当前层次下的文件的绝对路径长度就是文件名长度加上哈希表中当前层次对应的文件长度（注意需要加1操作，因为文件前需要添加'/'字符）
//3、使用 \n 切分整个字符串，然后遍历字符串数组
//根据\t数量，计算该文件层次
//如果包含".",说明是文件，更新绝对路径最大值
//如果不包含".",说明是目录，此时层次加1；更新绝对路径长度
public int lengthLongestPath(String input) {
    if(input == null || input.length()==0 ){ // 如果系统中没有文件，返回 0
        return 0;
    }
    //用哈希表来建立<文件层次，当前层次的绝对路径长度>之间的映射，
    Map<Integer,Integer> map = new HashMap<>();
    map.put(0, 0);
    //如果系统中没有文件，返回 0，所以初始化为0即可
    int res = 0;
    String[] files = input.split("\n");
    //以"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"为例
    //arr={"dir","\tsubdir1","\t\tfile1.ext","\t\tsubsubdir1","\tsubdir2","\t\tsubsubdir2","\t\t\tfile2.ext"}
    for(String file : files){
        //level是当前file所在层次，从0开始
        int level = file.lastIndexOf("\t") + 1; // 假设 file = "\tsubdir1"，level = 1
        file = file.substring(level); //去除 \t 后得到文件名称
        int len = file.length(); //当前文件长度
        if(file.contains(".")){ //说明是文件
            //map.get(level)当前层次文件绝对路径长度
            //目录后需要添加'/'字符，但是这里是文件，不需要添加'/'字符，所以不需要加 1
            res = Math.max(res,map.get(level)+len);
        }else{ //说明是目录，是下一个层次,更新map即可
            //map.get(level)+len注意需要加1操作，因为目录后需要添加'/'字符
            map.put(level+1,map.get(level)+len+1);
        }
    }
    return res;
}
```

# 队列
## 队列的典型应用
### 102
[102 Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }

    Queue<Pair<TreeNode,Integer>> queue=new LinkedList<>();
    queue.add(new Pair<TreeNode,Integer>(root,0));
    //root结点对应的是0层
    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        TreeNode node= (TreeNode) pair.getKey();
        int level= (int) pair.getValue();

        if(level==ret.size()){
            //因为level是从0开始的，当level=ret.size()表示需要新创建 List，来存储level层的元素
            ret.add(new ArrayList<>());
        }
        //ret.get(level)表示的是level层
        ret.get(level).add(node.val);

        if(node.left!=null){
            queue.add(new Pair<TreeNode,Integer>(node.left,level+1));
        }
        if(node.right!=null){
            queue.add(new Pair<TreeNode,Integer>(node.right,level+1));
        }
    }
    return ret;
}
```
### 232
[232 Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/description/)

* 解法一：
```java
/**
 * 思路一：
 * 使用一个栈来存储数据
 * 在push时使用另外一个栈进行转换
 * 使之符合队列FIFO的特性
 */
class MyQueue {
    Stack<Integer> s;

    /** Initialize your data structure here. */
    public MyQueue() {
       s=new Stack<>();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        Stack<Integer> s2=new Stack<>();
        //先将s中元素放入s2中
        while(!s.isEmpty()){
            s2.push(s.pop());
        }
        s.push(x);
        //再将s2中元素放入s中
        while(!s2.isEmpty()){
            s.push(s2.pop());
        }
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        return s.pop();
    }

    /** Get the front element. */
    public int peek() {
        return s.peek();
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return s.isEmpty();
    }
}
```
* 解法二：
```java
/**
 * 思路二：
 * 准备两个栈
 * 一个栈s1用于入队操作，若栈为空，此时进入的元素就是队首元素
 * 一个栈s2用于出队操作，若栈为空，则将s1中元素压入s2中，弹出s2的栈顶元素即可
 * 和一个front存储队列头元素
 */
class MyQueue {
    //入队操作使用
    private Stack<Integer> s1;
    //出队操作是使用
    private Stack<Integer> s2;
    //存储队列头元素
    private int front;

    /** Initialize your data structure here. */
    public MyQueue() {
        s1=new Stack<>();
        s2=new Stack<>();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        //方便后面的peek操作
       if(s1.isEmpty()){
           front=x;
       }
       s1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if(s2.isEmpty()){
            while(!s1.isEmpty()){
                s2.push(s1.pop());
            }
        }
        return s2.pop();
    }

    /** Get the front element. */
    public int peek() {
        if(!s2.isEmpty()){
           return s2.peek();
        }
        return front;
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return (s1.isEmpty() && s2.isEmpty());
    }
}
```

### 107
[107 Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/)
```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> ret=new ArrayList<>();
    if(root==null){
        return new ArrayList<>();
    }
    Queue<Pair<TreeNode,Integer>> queue=new LinkedList<>();
    queue.add(new Pair<TreeNode,Integer>(root,0));
    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        TreeNode node=(TreeNode) pair.getKey();
        int level=(int)pair.getValue();
        if(level==ret.size()){
            ret.add(new ArrayList<>());
        }
        ret.get(level).add(node.val);

        if(node.left!=null){
            queue.add(new Pair<TreeNode,Integer>(node.left,level+1));
        }
        if(node.right!=null){
            queue.add(new Pair<TreeNode,Integer>(node.right,level+1));
        }
    }
    Collections.reverse(ret);

    return ret;
}
```
### 103
[103 Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/)
```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }

    Queue<Pair<TreeNode,Integer>> queue=new LinkedList<>();
    queue.add(new Pair<TreeNode,Integer>(root,0));
    //root结点对应的是0层
    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        TreeNode node= (TreeNode) pair.getKey();
        int level= (int) pair.getValue();

        if(level==ret.size()){
            //因为level是从0开始的，当level=ret.size()表示需要新创建 List，来存储level层的元素
            ret.add(new ArrayList<>());
        }
        //ret.get(level)表示的是level层
        ret.get(level).add(node.val);

        if(node.left!=null){
            queue.add(new Pair<TreeNode,Integer>(node.left,level+1));
        }
        if(node.right!=null){
            queue.add(new Pair<TreeNode,Integer>(node.right,level+1));
        }
    }
    //进行层次遍历后，对于偶数层的数据，进行逆序处理
    int cnt=0;
    for(List<Integer> list:ret){
        if(cnt%2==1){
            Collections.reverse(list);
        }
        cnt++;
    }
    return ret;
}
```
### 199
[199 Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/description/)
```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }
    Queue<TreeNode> queue=new LinkedList<>();
    queue.add(root);
    
    while(!queue.isEmpty()){
        //nodeNumsEachLevel表示每层的节点数
        int nodeNumsEachLevel=queue.size();
        while(nodeNumsEachLevel>0){
            TreeNode tmp=queue.poll();
            if(tmp.left!=null){
                queue.add(tmp.left);
            }
            if(tmp.right!=null){
                queue.add(tmp.right);
            }
            //每出队一次，该层就减少一个节点
            nodeNumsEachLevel--;
            //nodeNumsEachLevel==0，该层的最右侧节点
            if(nodeNumsEachLevel==0){
                ret.add(tmp.val);
            }
        }
    }
    return ret;
}
```
### 637
[637 Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/)
```java
public List<Double> averageOfLevels(TreeNode root) {
    //存储层序遍历各层的元素
    List<List<Integer>> list=new ArrayList<>();
    Queue<Pair> q=new LinkedList<>();
    q.add(new Pair(root,0));
    while(!q.isEmpty()){
        Pair pair=q.poll();
        TreeNode treeNode=pair.treeNode;
        int level=pair.level;
        if(level==list.size()){
            list.add(new ArrayList<>());
        }
        list.get(level).add(treeNode.val);
        if(treeNode.left!=null){
            q.add(new Pair(treeNode.left,level+1));
        }
        if(treeNode.right!=null){
            q.add(new Pair(treeNode.right,level+1));
        }
    }

    List<Double> res=new ArrayList<>();
    if(list.size()==0){
        return res;
    }
    int sum=0;
    for(List<Integer> tmp:list){
        res.add(getAverage(tmp));
    }
    return res;
}

private double getAverage(List<Integer> list){
    //这里要注意 节点值为2147483647相加的情况
    long sum=0L;
    for(Integer num:list){
        sum+=num;
        //[2147483647.0,2147483647.0]
    }
    return (sum*1.0)/list.size();
}

private class Pair{
    TreeNode treeNode;
    int level;
    Pair(TreeNode treeNode,int level){
        this.treeNode=treeNode;
        this.level=level;
    }
}
```

## BFS和图的最短路径
### 279
[279 Perfect Squares](https://leetcode.com/problems/perfect-squares/description/)

* 问题：

给出一个正整数n，寻找最少的完全平方数，使他的平方和为n。

完全平方数：1，4，9，16 ...

* 举例：

12=4+4+4

13=4+9

* 解题：

确定问题：

**没有解怎么办**？ 一定有解，因为1是完全平方数，最差的情况就是n=n个1相加

思路：

1、贪心算法？

使用贪心策略：每次取最大的完全平方数，则12=9+1+1+1，但是12=4+4+4是最终解。

2、对问题建模：将整个问题转化为**图论问题**。

从n到0，每个数字表示一个节点；

如果两个数字x到y相差一个完全平方数，则连接一条边。我们就得到了填个无权图。

那么，原来的问题就转化成，求这个无权图中从n到0的最短路径。

<div align="center"><img src="pics//stackQueue//stack_8.png"/></div>
 
图中1->0的距离是1,2->1的就离是1,
3->2的距离是1，
4->3的距离是1，
4->0的距离是0

<div align="center"><img src="pics//stackQueue//stack_9.png" width="600"/></div>
<div align="center"><img src="pics//stackQueue//stack_10.png" width="600"/></div>
<div align="center"><img src="pics//stackQueue//stack_11.png" width="600"/></div>
<div align="center"><img src="pics//stackQueue//stack_12.png" width="600"/></div>

```java
private class Pair{
    int num;
    //记录节点的数值
    int steps;
    //记录num数值该走几步
    Pair(int num,int steps){
        this.num=num;
        this.steps=steps;
    }
}

public int numSquares(int n) {
    Queue<Pair> queue=new LinkedList<>();
    queue.add(new Pair(n,0));
    
    boolean[] isVisited=new boolean[n+1];
    isVisited[n]=true;

    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        int num=pair.num;
        int steps=pair.steps;
        if(num==0){
            return steps;
        }
        for(int i=1;;i++){
            int tmp=num-i*i;
            if(tmp<0){
                break;
            }
            if(!isVisited[tmp]){
                queue.add(new Pair(tmp,steps+1));
                isVisited[tmp]=false;
            }
        }
    }
    //如果结果不存在，就返回0
    return 0;
}
```
### 127
[127 Word Ladder](https://leetcode.com/problems/word-ladder/description/)
```java
/**
 * BFS
 * 将这个问题看成图问题:
 * word1-->word2 的路径就是word1和word2 "相似"（word1和wordd2根据题目规则可以相互转化）
 * 最后从beginWord走到endWord.
 */
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    //使用set去除重复元素-->BFS更高效
    Set<String> wordSet=new HashSet<>();
    for(String word:wordList){
        wordSet.add(word);
    }

    //存储已经访问过的节点，保证下次不会再走了
    Set<String> visited = new HashSet<>();

    //从beginWord开始进行BFS
    Queue<Pair> q=new LinkedList<>();
    //从 begin开始，走的是第一步
    q.add(new Pair(beginWord,1));
    while (!q.isEmpty()){
        Pair p=q.poll();
        //访问当前节点
        String curWord=p.word;
        int curStep=p.step;
        visited.clear();
        //看下一个节点的情况
        for(String word:wordSet){
            if(isSimilar(curWord,word)){ //isSimilar(curWord,word) 说明beginWod-->word有路径
                if(word.equals(endWord)){
                    return curStep+1;
                }
                //将word加入队列，即访问了word
                q.add(new Pair(word,curStep+1));
                visited.add(word);
            }
        }
        //删除已经访问过的节点
        for(String w:visited){
            wordSet.remove(w);
        }
    }
    return 0;
}

private class Pair{
    String word;
    int step;
    Pair(String word,int step){
        this.word=word;
        this.step=step;
    }
}

//判断word1和word2是否相似，即word1和word是否可以相互转化
private boolean isSimilar(String word1,String word2){
    if(word1.length()!=word2.length() || word1.equals(word2)){
        return false;
    }
    int diff=0;
    for(int i=0;i<word1.length();i++){
        if(word1.charAt(i)!=word2.charAt(i)){
            diff++;
        }
        if(diff>1){
            return false;
        }
    }
    return true;
}
```
### 126
[126 Word Ladder II](https://leetcode.com/problems/word-ladder-ii/description/)
```java

```

### 752
[752 Open the Lock](https://leetcode.com/problems/open-the-lock/)
```java
public int openLock(String[] deadends, String target) {
    Set<String> deadSet=new HashSet<>();
    for(String deadend:deadends){
        deadSet.add(deadend);
    }

    if(deadSet.contains(target) || deadSet.contains("0000")){
        return -1;
    }

    Set<String> visited=new HashSet<>();
    Queue<Pair> q=new LinkedList<>();
    q.add(new Pair("0000",0));
    visited.add("0000");
    while(!q.isEmpty()){
        Pair p=q.poll();
        String curS=p.s;
        int curTurn=p.turn;
        Set<String> next=getNextLock(curS,deadSet);
        for(String lock:next){
            if(!visited.contains(lock)){
                if(target.equals(lock)){
                    return curTurn+1;
                }
                visited.add(lock);
                q.add(new Pair(lock,curTurn+1));
            }
        }
    }
    return -1;
}

//锁的密码是s时，获取下一个有可能的锁密码
private Set<String> getNextLock(String s,Set<String> deadends){
    Set<String> res=new HashSet<>();
    assert s.length()==4;
    for(int i=0;i<4;i++){
        int num = s.charAt(i)- '0';
        int d = num + 1;
        if(d > 9) d = 0;
        String t=s.substring(0,i)+((char) (d+'0'))+s.substring(i+1,4);
        if(!deadends.contains(t)){
            res.add(t);
        }
        d=num-1;
        if(d < 0) d = 9;
        t=s.substring(0,i)+((char) (d+'0'))+s.substring(i+1,4);
        if(!deadends.contains(t)){
            res.add(t);
        }
    }
    return res;
}

private class Pair{
    String s;
    int turn;
    Pair(String s,int turn){
        this.s=s;
        this.turn=turn;
    }
}
```


## 优先队列
* [堆的底层实现，白板编程](https://github.com/DuHouAn/DataStructureNotes/blob/master/src/code_01_heap/MaxHeap.java)

* Java中优先队列的使用
```java
public class PriorityQueueUsing {
    public static void main(String[] args) {
        Random random=new Random();

        //Java语言，默认情况下是最小堆
        PriorityQueue<Integer> pq=new PriorityQueue<>();
        for(int i=0;i<10;i++){
            int num=random.nextInt(100)+1;
            //产生[1,100]之间的随机数
            System.out.println("insert "+num+" into priority queue.");
            pq.add(num);
        }
        while(!pq.isEmpty()){
            int num=pq.poll();
            System.out.print(num+" ");
        }
        System.out.println();

        //底层使用最小堆
        PriorityQueue<Integer> pq2=new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                int num=o2-o1;
                return num;
            }
        });
        for(int i=0;i<10;i++){
            int num=random.nextInt(100)+1;
            //产生[1,100]之间的随机数
            System.out.println("insert "+num+" into priority queue.");
            pq2.add(num);
        }
        while(!pq2.isEmpty()){
            int num=pq2.poll();
            System.out.print(num+" ");
        }
        System.out.println();

        //自定义Comparator的优先队列
        PriorityQueue<Integer> pq3=new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                int num=o2%10-o1%10;
                //这里是按照个位上的数字，得到的最大堆
                return num;
            }
        });
        for(int i=0;i<10;i++){
            int num=random.nextInt(100)+1;
            //产生[1,100]之间的随机数
            System.out.println("insert "+num+" into priority queue.");
            pq3.add(num);
        }
        while(!pq3.isEmpty()){
            int num=pq3.poll();
            System.out.print(num+" ");
        }
        System.out.println();
    }
}
```

## 优先队列相关的算法问题
### 347
[347 Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/)

* 问题：

给定一个非空数组，返回前k个出现频率最高的元素。

* 示例：

给定[1,1,1,2,2,3],k=2

返回[1,2]

* 解题：

1、确定问题：

k的合法性问题

2、思路一：

扫描一遍统计频率；

排序找到前k个出现频率最高的元素。

时间复杂度O(n log n)

3、思路二：

维护一个优先队列

时间复杂度O(n log k)

```java
private class Pair implements Comparable<Pair> {
    int numFreq;
    int num;
    Pair(int numFreq,int num){
        this.numFreq=numFreq;
        this.num=num;
    }

    @Override
    public int compareTo(Pair o) {
        return this.numFreq-o.numFreq;
    }
}

public List<Integer> topKFrequent(int[] nums, int k) {
    //统计数字出现的频率
    Map<Integer,Integer> map=new HashMap<>();
    for(int num:nums){
        int freq=map.get(num)==null?0:map.get(num);
        map.put(num,++freq);
    }

    //维护一个优先队列，最小堆，维护当前频率最高的元素
    PriorityQueue<Pair> priorityQueue=new PriorityQueue<>();
    //pair存的是（频率，元素）的形式
    for(Integer num:map.keySet()){
        int numFreq=map.get(num);
        if(priorityQueue.size()==k){
            if(numFreq>priorityQueue.peek().numFreq){
                priorityQueue.poll();
                priorityQueue.add(new Pair(numFreq,num));
            }
        }else{
            priorityQueue.add(new Pair(numFreq,num));
        }
    }

    List<Integer> ret=new ArrayList<>();
    while(!priorityQueue.isEmpty()){
        ret.add(priorityQueue.poll().num);
    }
    return ret;
}
```
### 23
[23 Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)
```java
//思路一：逐步合并有序链表,n是数组长度，K是数组中的链表平均长度
//时间复杂度：O(n*K)
//空间复杂度：O(1)
public ListNode mergeKLists(ListNode[] lists) {
    if(lists==null || lists.length==0){
        return null;
    }

    //将该数组中元素逐步合并
    ListNode head=lists[0];
    for(int i=1;i< lists.length;i++){
        head=mergeTwoLists(head,lists[i]);
    }
    return head;
}

private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if(l1==null){
        return l2;
    }
    if(l2 ==null){
        return l1;
    }

    ListNode dummyHead=new ListNode(0);

    ListNode cur1=l1;
    ListNode cur2=l2;
    ListNode cur=dummyHead;
    while(cur1!=null && cur2!=null){
        if(cur1.val <cur2.val){
            cur.next=cur1;
            cur1=cur1.next;
        }else{
            cur.next=cur2;
            cur2=cur2.next;
        }
        cur=cur.next;
    }
    if(cur1!=null){
        cur.next=cur1;
    }
    if(cur2!=null){
        cur.next=cur2;
    }

    ListNode retNode=dummyHead.next;
    dummyHead.next=null;
    return retNode;
}
```

```java
//思路二:使用优先队列,n是数组长度，K是链表平均长度
//时间复杂度：O(n * k log k)
//空间复杂度：O(n)
public ListNode mergeKLists(ListNode[] lists) {
    if(lists==null || lists.length==0){
        return null;
    }
    if (lists.length == 1){
        return lists[0];
    }

    //维护一个最小堆
    PriorityQueue<ListNode> queue = new PriorityQueue<>(new Comparator<ListNode>() {
        public int compare(ListNode o1, ListNode o2) {
            return o1.val - o2.val;
        }
    });
    for (int i = 0; i < lists.length; i++) {
        //这里只是加了每个链表的头结点
        if (lists[i] != null) queue.add(lists[i]);
    }

    ListNode dummyHead=new ListNode(-1);
    ListNode cur=dummyHead;

    while(!queue.isEmpty()){
        ListNode tmp=queue.poll();
        cur.next=tmp;
        cur=tmp;
        //看看该结点是否有下一个结点，这样就确保所有的元素都加入优先队列中了。
        if (tmp.next != null){
            queue.add(tmp.next);
        }
    }
    cur.next=null;

    ListNode retNode=dummyHead.next;
    dummyHead=null;

    return retNode;
}
```

### 692
[692 Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/)
```java
public List<String> topKFrequent(String[] words, int k) {
    List<String> res=new ArrayList<>();
    PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>() {
        @Override
        public int compare(Pair p1, Pair p2) {
            //先按照词频进行升序排列
            int num=p1.freq-p2.freq;
            //再按照word种地字母顺序进行排序
            int num2=(num==0)?p2.word.compareTo(p1.word):num;
            return num2;
        }
    });

    //统计单词及词频
    HashMap<String,Integer> map=new HashMap<>();
    for(String word:words){
        int freq=map.getOrDefault(word,0);
        map.put(word,++freq);
    }

    for(String word:map.keySet()){
        pq.add(new Pair(word,map.get(word)));
        if (pq.size() > k){
            pq.poll();
        }
    }

    while(!pq.isEmpty()){
        Pair p=pq.poll();
        res.add(p.word);
    }
    Collections.reverse(res);
    return res;
}

//封装单词和对应的词频
private class Pair{
    String word;
    int freq;
    public Pair(String word,int freq){
           this.word=word;
           this.freq=freq;
    }
}
```

## 更多和栈相关的问题
### 133
[133 Clone Graph](https://leetcode.com/problems/clone-graph/)
```java
/**
* 思路一:BFS
*/
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if(node==null){
        return null;
    }
    Map<UndirectedGraphNode, UndirectedGraphNode> map=
            new HashMap<UndirectedGraphNode, UndirectedGraphNode>();
    Queue<UndirectedGraphNode> q=new LinkedList<>();
    UndirectedGraphNode newNode=new UndirectedGraphNode(node.label);
    map.put(node,newNode);
    q.add(node);
    while(!q.isEmpty()){
        UndirectedGraphNode curNode=q.poll();
        List<UndirectedGraphNode> curNeightbors=curNode.neighbors;
        for(UndirectedGraphNode neighbor:curNeightbors){
            if(map.containsKey(neighbor)){
                map.get(curNode).neighbors.add(map.get(neighbor));
            }else{
                UndirectedGraphNode newNode2=new UndirectedGraphNode(neighbor.label);
                map.put(neighbor,newNode2);
                map.get(curNode).neighbors.add(newNode2);
                q.add(neighbor);
            }
        }
    }
    return newNode;
}
```

```java
/**
* 思路二：DFS
*/
Map<UndirectedGraphNode, UndirectedGraphNode> map=
        new HashMap<UndirectedGraphNode, UndirectedGraphNode>();
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if(node==null){
        return null;
    }
    //不访问重复的顶点
    if(map.containsKey(node)){
        return map.get(node);
    }
    UndirectedGraphNode newNode=new UndirectedGraphNode(node.label);
    map.put(node,newNode);
    for(UndirectedGraphNode neighbor: node.neighbors){
        newNode.neighbors.add(cloneGraph(neighbor));
    }
    return newNode;
}
```

### 856 
[856 Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)

* 解题思路一：
```java
/**
 * 思路一：
 * 用栈解决的话，如果遇到左括号，则入栈。
 * 如果遇到右括号，判断栈顶是不是右括号，如果是则说明是()，出栈并压数字1；
 * 否则说明是(A)型，将内部数字全部加起来的和*2，得到的结果再次入栈。
 * 最后栈内是各种数字，加起来就可以了。
 */
public int scoreOfParentheses(String S) {
    int res=0;
    Stack<String> s=new Stack<>();
    for(int i=0;i<S.length();i++){
        String c=S.charAt(i)+"";
        if("(".equals(c)) {
            s.push("(");
        }else{
            if (!s.isEmpty() && s.peek().equals("(")){
                s.pop();
                s.push("1");
            }else {
                int subSum=0;
                while (!s.isEmpty() && !s.peek().equals("(")) {
                    String num = s.pop();
                    subSum += Integer.parseInt(num);
                }
                //将对应的“（”删除
                if (!s.isEmpty()) {
                    s.pop();
                }
                s.push(subSum * 2 + "");
            }
        }
    }
    while (!s.isEmpty()){
        String num=s.pop();
        res+=Integer.parseInt(num);
    }
    return res;
}
```
* 解题思路二：
```java
/**
 * 思路二：
 * "(()(()))" -->转化为："(())"+"((()))" --> 计算 2^(2-1) + 2^(3-1)
 * "(()(()()))" --> 转换为："(())"+"((()))"+"((())))" --> 计算 2^(2-1)+2^(3-1)+2^(3-1)
 */
public int scoreOfParentheses(String S) {
    int res = 0;
    //记录"("的数量
    int balance = 0;
    for(int i=0;i<S.length();i++){
        char c=S.charAt(i);
        if(c=='('){
            balance++;
        }else{
            balance--;
            if(S.charAt(i-1)=='('){
                res+=(1<<balance);
            }
        }
    }
    return res;
}
```
### 227 
[227 Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)
```java
/**
 * 思路：
 * 关键在于怎么处理乘法和除法，如果是乘法或者除法，我们需要用前面的数和当前的数做运算。
 * 因此此处可以用栈来记录前面的数字，用一个符号变量记录前一个符号，当遍历到一个新数字时，
 * 判断一下前面的符号是什么，如果是乘除，就和前面的数字运算，
 * 如果是+，就向栈中push这个数字，如果是-，就push这个数字的负数。
 * 遍历到结尾，把最后一个数字入栈，此时栈中存放的都是要进行加法运算的数字。
 */
public int calculate(String s) {
    if(s==null || s.length()==0){
        return 0;
    }
    //stack存储的是数字，其中的所有数组只要进行加法即可。
    Stack<Integer> stack=new Stack<>();;

    //"351"这样的字符串，使用num保存各位数据
    int num=0;
    char op='+';
    //用一个符号变量记录前一个符号
    for(int i=0;i<s.length();i++){
        char c=s.charAt(i);
        if(Character.isDigit(c)){
            num=num*10+(c-'0');
        }
        if((!Character.isDigit(c) && c!=' ') || (i==s.length()-1)){
            //(i==s.length()-1)是数字，是要进行入栈处理的
            if(op=='+'){
                stack.push(num);
            }else if(op=='-'){
                stack.push(-num);
            }else if(op=='*'){
                stack.push(stack.pop()*num);
            }else if(op=='/'){
                stack.push(stack.pop()/num);
            }
            op=c;
            num=0;
        }
    }
    int res=0;
    while (!stack.isEmpty()) {
        res += stack.pop();
    }
    return res;
}
```

### 901
[901 Online Stock Span](https://leetcode.com/problems/online-stock-span/)
```java
class StockSpanner {
    private Stack<Pair<Integer,Integer>> stack;

    public StockSpanner() {
        stack=new Stack<>();
    }

    public int next(int price) {
        if(stack.isEmpty() || stack.peek().getKey()>price){
            stack.push(new Pair<>(price,1));
            return 1;
        }
        int cnt=1;
        while(!stack.isEmpty() && stack.peek().getKey()<=price){
            cnt+=stack.pop().getValue();
        }
        stack.push(new Pair<>(price,cnt));
        return cnt;
    }
}
```

## 更多和队列相关的问题
### 622
[622 Design Circular Queue](https://leetcode.com/problems/design-circular-queue/)

[参考数据结构-队列笔记](https://github.com/DuHouAn/Java-Notes/blob/master/DataStructureNotes/notes/01栈和队列.md)

```java
class MyCircularQueue {
        private int[] data;

        //front==tail 队列为空
        //(tail+1)/data.length==front队列为空
        private int front,tail;
        private int size;

        /** Initialize your data structure here. Set the size of the queue to be k. */
        public MyCircularQueue(int k) {
            //损失一个1单位，用来区分队列是满的还是空的
            data=new int[k+1];
            front=0;
            tail=0;
            size=0;
        }

        /** Insert an element into the circular queue. Return true if the operation is successful. */
        public boolean enQueue(int value) {
            //先判断队列是否满了
            if(isFull()){
                return false;
            }
            data[tail]=value;
            tail=(tail+1)%data.length;
            size++;
            return true;
        }

        /** Delete an element from the circular queue. Return true if the operation is successful. */
        public boolean deQueue() {
            if(isEmpty()){
                return false;
            }
            //E保存出队的元素
            int E=data[front];
            front=(front+1)%data.length;
            size--;
            return true;
        }

        /** Get the front item from the queue. */
        public int Front() {
            if(isEmpty()){
                return -1;
            }
            return data[front];
        }

        /** Get the last item from the queue. */
        public int Rear() {
            if(isEmpty()) {
                return -1;
            }
            //注意这是循环队列，tail的值是循环变化的
            return data[(tail+data.length-1)%data.length];
        }

        /** Checks whether the circular queue is empty or not. */
        public boolean isEmpty() {
            return front==tail;
        }

        /** Checks whether the circular queue is full or not. */
        public boolean isFull() {
            return (tail+1)%data.length==front;
        }
    }
```