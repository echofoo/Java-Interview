- [返回首页](https://github.com/DuHouAn/Java-Interview)

# [第六章 递归和回溯法](#递归和回溯法)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :--- | :---: | :---: | :---: | :---: |
| [6-1 树形问题 Letter Combinations of a Phone Number](#树形问题) | [17](#17) | [无] | [690](#690) | |
| [6-2 什么是回溯](#什么是回溯) |  | [93](#93)  | [797](#797) | |
| [6-3 排列问题 Permutations](#排列问题) | [46](#46) | [47](#47) | [784](#784) | |
| [6-4 组合问题 Combinations](#组合问题) | [77](#77) | [131](#131) [78*](#78) | | |
| [6-5 回溯法解决组合问题的优化](#回溯法解决组合问题的优化) | [77](#77题的优化)| [39](#39) [40](#40) [216](#216)  [90](#90) [401](#401) | [254](#254) | |
| [6-6 二维平面上的回溯法 Word Search](#二维平面上的回溯法) | [79*](#79) | [无] | | |
| [6-7 floodfill算法，一类经典问题 Number of Islands](#floodfill算法之一类经典问题) | [200](#200) | [130](#130) [417](#417) | [695](#695) [733](#733) | 711 |
| [6-8 回溯法是经典人工智能的基础 N Queens](#回溯法是经典人工智能的基础) | [51*](#51) | [52](#52) [37](#37) | | |
| [补充1 更多回溯问题](#更多回溯问题) | [473](#473) | [698](#698) [22](#22)| | |
| [补充2 其他递归问题](#其他递归问题) | [无] | [无] | | 390 |

# 递归和回溯法
## 树形问题
### 17
[17 Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)

* 问题：

<div align="center"><img src="pics//backtrack//backtrack_1.png" width="600"/></div>

* 示例：

<div align="center"><img src="pics//backtrack//backtrack_2.png" width="600"/></div>

* 解题：

(1)确定问题

<div align="center"><img src="pics//backtrack//backtrack_3.png" width="600"/></div>

(2)解题思路

<div align="center"><img src="pics//backtrack//backtrack_4.png" width="600"/></div>

digits是数字字符串

s(digits)是digits所能代表的字母字符串

letter(digits[i])是digits[i]所能代表的字母

 s(digits[0...n-1])
 
= letter(digits[0]) + s(digits[1...n-1])

= letter(digits[0]) + letter(digits[1]) + s(digits[2...n-1])

= ...

(3)代码
```java
//注意：0和1是不表示字母的
private String[] letterMap={
        " ",
        "",
        "abc",//2
        "def",//3
        "ghi",//4
        "jkl",//5
        "mno",//6
        "pqrs",//7
        "tuv",//8
        "wxyz"//9
};

private ArrayList<String> res;

//s中保存从digits[0...index-1]翻译得到的一个字母字符串
//寻找和digits[index]匹配的字母，获得digits[0...index]翻译得到的字符串
private void findCombination(String digits,int index,StringBuilder s){
    //递归结束条件
    if(index==digits.length()){
        //保存s
        res.add(s.toString());
        return;
    }
    // c表示digits的index位置的数字
    char c=digits.charAt(index);
    assert  c>='0' && c<='9'&& c!='0';
    String letters=letterMap[c-'0'];
    for(int i=0;i<letters.length();i++){
        s.append(letters.charAt(i));
        findCombination(digits,index+1,s);
        s.deleteCharAt(s.length()-1);
    }
}

public List<String> letterCombinations(String digits) {
    res=new ArrayList<>();
    //当digit为空字符串时，返回的是空集合
    if("".equals(digits)){
        return res;
    }
    StringBuilder s = new StringBuilder();
    findCombination(digits,0,s);
    return res;
}
```

### 690
[690 Employee Importance](https://leetcode.com/problems/employee-importance/description/)

```java
/**
* 问题描述：
给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。
比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。
那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。
注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。
现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。

示例 1:
输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
输出: 11
解释:
员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。
因此员工1的总重要度是 5 + 3 + 3 = 11。

注意:
一个员工最多有一个直系领导，但是可以有多个直系下属员工数量不超过2000。
*/
//思路一：写法一：直接暴力求解，这里循环是可终止的，所以不需要特殊的递归结束条件
public int getImportance(List<Employee> employees, int id) {
    int res=0;
    for(Employee e:employees){
        if(e.id==id){
            res=e.importance;
            List<Integer> subordinates=e.subordinates;
            if(subordinates!=null || subordinates.size()!=0){
                for(Integer subIds:subordinates){
                    res+=getImportance(employees,subIds);
                }
            }
        }
    }
    return res;
}
```

```java
//思路一：写法二，减少了遍历次数
public int getImportance(List<Employee> employees, int id) {
    Employee master = getEmployee(employees,id);
    int sum = master.importance;
    List<Integer> list = master.subordinates;
    if(list.size()!=0){
        for(Integer employeeId : list){
            sum += getImportance(employees,employeeId);
        }
    }
    return sum;
}

//根据员工 id获取该员工信息
private Employee getEmployee(List<Employee> employees, int id){
    for(Employee employee : employees){
        if(employee.id == id){
            return employee;
        }
    }
    return null;
}
```

```java
//思路二：可以将这个employee的id表示一棵树，
// 上下级的关系，就是层与层的关系,进行层次遍历，这样可以不使用递归了。
public int getImportance(List<Employee> employees, int id) {
    //map存储<id,id编号的员工信息>,方便我们根据 id,即可获得员工信息
    Map<Integer,Employee> map = new HashMap<>();
    for(Employee employee:employees){
        map.put(employee.id,employee);
    }
    int res = 0;
    Queue<Integer> queue = new LinkedList<>();
    queue.add(id);
    while(!queue.isEmpty()){
        Integer sudId = queue.poll();
        res += map.get(sudId).importance;
        for(Integer employeeId : map.get(sudId).subordinates){
            queue.add(employeeId);
        }
    }
    return res;
}
```

## 什么是回溯
```java
public class BackTrackTest {
    //注意：0和1是不表示字母的
    private String[] letterMap={
            " ",
            "",
            "abc",//2
            "def",//3
            "ghi",//4
            "jkl",//5
            "mno",//6
            "pqrs",//7
            "tuv",//8
            "wxyz"//9
    };

    private ArrayList<String> res;

    //s中保存从digits[0...index-1]翻译得到的一个字母字符串
    //寻找和digits[index]匹配的字母，获得digits[0...index]翻译得到的字符串
    private void findCombination(String digits,int index,String s){
        //递归结束条件
        if(index==digits.length()){
            //保存s
            res.add(s);
            System.out.println("get "+s+" ,return");
            return;
        }
        // c表示digits的index位置的数字
        char c=digits.charAt(index);
        assert  c>='0' && c<='9'&& c!='0';
        String letters=letterMap[c-'0'];
        for(int i=0;i<letters.length();i++){
            System.out.println("digits["+index+"]="+c+" ,use "+letters.charAt(i));
            findCombination(digits,index+1,s+letters.charAt(i));
        }
        System.out.println("digits["+index+"]="+c+" complete,return");
    }

    public List<String> letterCombinations(String digits) {
        res=new ArrayList<>();
        //当digit为空字符串时，返回的是空集合
        if("".equals(digits)){
            return res;
        }
        findCombination(digits,0,"");
        return res;
    }

    @Test
    public void test(){
        List<String> res=letterCombinations("23");
    }
}
```
输出结果:
```java
digits[0]=2 ,use a
digits[1]=3 ,use d
get ad ,return
digits[1]=3 ,use e
get ae ,return
digits[1]=3 ,use f
get af ,return
digits[1]=3 complete,return
digits[0]=2 ,use b
digits[1]=3 ,use d
get bd ,return
digits[1]=3 ,use e
get be ,return
digits[1]=3 ,use f
get bf ,return
digits[1]=3 complete,return
digits[0]=2 ,use c
digits[1]=3 ,use d
get cd ,return
digits[1]=3 ,use e
get ce ,return
digits[1]=3 ,use f
get cf ,return
digits[1]=3 complete,return
digits[0]=2 complete,return
```
时间复杂度：

近似为 3^n =O(2^n)

### 93
[93 Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses/description/)
```java
/**
* 问题描述：
给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

* 示例:
输入: "25525511135"
输出: ["255.255.11.135", "255.255.111.35"]
*/
/**
 * 在输入字符串中加入三个点，将字符串分为四段，每一段必须合法，求所有可能的情况。
 * 我们用k来表示当前还需要分的段数，如果k = 0，则表示三个点已经加入完成，四段已经形成，若这时字符串刚好为空，则将当前分好的结果保存。
 * 若k != 0,
 * 则对于每一段，我们分别用一位，两位，三位来尝试，分别判断其合不合法，如果合法，则调用递归继续分剩下的字符串，最终和求出所有合法组合。
 * @param s
 * @return
 */
public List<String> restoreIpAddresses(String s){
    List<String> res=new ArrayList<>();
    if(s.length()<4 || s.length()>12){
        return res;
    }
    restore(s,1,"",res);
    return res;
}

//count表示的是取的是第count段
//p存储的前段的IP地址
//s表示的每一段的IP地址
private void restore(String s,int count,String p,List<String> res){
    if(count==4 && isValid(s)){
        res.add(p+s);
        return;
    }
    //Math.min(4, s.length())后面几位少于4的情况比如，0000
    for(int i=1;i< Math.min(4,s.length());i++){
        String cur=s.substring(0,i);
        if(isValid(cur)){
            restore(s.substring(i),count+1 ,p+cur+".",res);
        }
    }
    return;
}

/**
 * IP地址总共有四段，
 * 每一段可能有一位，两位或者三位，范围是[0, 255]，
 * 题目明确指出输入字符串只含有数字，所以当某段是三位时，我们要判断其是否越界（>255)，
 * 还有一点很重要的是，当只有一位时，0可以成某一段，
 * 如果有两位或三位时，像 00， 01， 001， 011， 000等都是不合法的，
 * 所以我们还是需要有一个判定函数来判断某个字符串是否合法。
 */
private boolean isValid(String s){
    //该字符串的第一个元素是0,则该字符串要合法的话，就只能是0
    if(s.charAt(0)=='0'){
        return "0".equals(s);
    }
    int num=Integer.parseInt(s);
    return num>0 && num<256;
}
```

### 797
[797 All Paths From Source to Target](https://leetcode.com/problems/all-paths-from-source-to-target/description/)

* 示例：

Input: [[1,2], [3], [3], []]

Output: [[0,1,3],[0,2,3]]

Explanation: The graph looks like this:
 0--->1
 |    |
 v    v
 2--->3

这里面graph是使用的二维数组表示的，[[1,2], [3], [3], []]可以使用矩阵这样表示

<div align="center"><img src="pics//backtrack//backtrack_28.png" width="600"/></div>
 
```java
private List<List<Integer>> res;
/**
 * 思路：
 * 分析可知解集是子集树
 */
public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    res=new ArrayList<>();
    int n=graph.length;
    if(n==0){
        return res;
    }
    List<Integer> p=new ArrayList<>();
    p.add(0);
    findPath(graph,0,n-1,p);
    return res;
}

//p保存的是[start...end]点的路径
private void findPath(int[][] graph,int start,int end,List<Integer> p){
    if(start==end){
        res.add(new ArrayList<>(p));
        return;
    }

    //(index,nodes[i])表示一条边
    int[] vertexs=graph[start];
    if(vertexs.length!=0){
        for(int vertex:vertexs){
            p.add(vertex);
            //查找到vertex顶点接着向下寻找
            findPath(graph,vertex,end,p);
            p.remove(p.size()-1);
        }
    }
}
```

## 排列问题
### 46
[46 Permutations](https://leetcode.com/problems/permutations/description/)

* 问题：

给定一个整型数组，其中每一个元素个不相同，返回这些元素所有排列的可能。

* 示例：

对于[1,2,3]

返回[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

* 解题：

典型的使用回溯法来解决的问题。

<div align="center"><img src="pics//backtrack//backtrack_5.png" width="600"/></div>

数学表达式的形式：

<div align="center"><img src="pics//backtrack//backtrack_6.png" width="600"/></div>

```java
private List<List<Integer>> res;

//用来去除已经访问过的元素,该数组长度为nums.lenth,其下标表示的元素和nums的下标表示的元素相同
private boolean[] visitecd;

//p中保存一个有index的元素的排列
//向这个排列的末尾添加第(index+1)个元素，获的有(index+1)个元素的排列
private void generatePermutation(int[] nums,int index,List<Integer> p){
    if(index==nums.length){
        //这里要尤其注意，p传过来的是引用
        res.add(new ArrayList<>(p));
        return;
    }
    for(int i=0;i<nums.length;i++){
        //判断nums[i]是否在p元素中
        if(visitecd[i]==false){
            //将nums[i]元素直接放入p中
            p.add(nums[i]);
            visitecd[i]=true;
            generatePermutation(nums,index+1,p);

            //回溯法的精髓
            p.remove(p.size()-1);
            visitecd[i]=false;
        }
    }
    return;
}

public List<List<Integer>> permute(int[] nums) {
    res=new ArrayList<>();
    if(nums.length==0){
        return res;
    }
    visitecd=new boolean[nums.length];
    List<Integer> p=new ArrayList<>();
    generatePermutation(nums,0,p);
    return res;
}
```

### 47
[47 Permutations II](https://leetcode.com/problems/permutations-ii/description/)
```java
/**
* 问题描述：
给定一个可包含重复数字的序列，返回所有不重复的全排列。
  
* 示例:
输入: [1,1,2]
输出:
[
[1,1,2],
[1,2,1],
[2,1,1]
]
*/
private List<List<Integer>> res;

private boolean[]  vistied;

private void generatePermutation(int[] nums,int index,List<Integer> p){
    if(nums.length==index){
        res.add(new ArrayList<>(p));
        return;
    }
    for(int i=0;i<nums.length;i++){
        if(vistied[i]==false){
            //nums[i]是重复元素，并且相邻两个元素都没被访问过
            if(i>0 && nums[i]==nums[i-1] && vistied[i-1]==false){
                continue;
            }
            //要加入的元素，与前一个元素不能相同
            p.add(nums[i]);
            vistied[i]=true;

            generatePermutation(nums,index+1,p);

            p.remove(p.size()-1);
            vistied[i]=false;
        }
    }
    return;
}

/**
 * 思路：
 * 看到重复元素，首先要想到能否使用排序。
 * 这里如果已经访问过的数字如果是重复元素,排序后，相邻元素相同，则该元素是重复元素
 */
public List<List<Integer>> permuteUnique(int[] nums) {
    res=new ArrayList<>();
    if(nums.length==0){
        return res;
    }
    //先对数组进行排序，方便后面的
    Arrays.sort(nums);
    List<Integer> p=new ArrayList<>();
    vistied=new boolean[nums.length];
    generatePermutation(nums,0,p);
    return res;
}
```

### 784
[784 Letter Case Permutation](https://leetcode.com/problems/letter-case-permutation/description/)
```java
private List<String> res;

//处理index位置的字符
//如果是字母，那么要么进行小写处理，要么进行大写处理
private void replace(int index,StringBuilder builder){
    if(index==builder.length()){
        res.add(builder.toString());
        return;
    }
    char ch=builder.charAt(index);
    if(Character.isLetter(ch)){
        builder.setCharAt(index,Character.toLowerCase(ch));
        replace(index+1,builder);
        builder.setCharAt(index,Character.toUpperCase(ch));
        replace(index+1,builder);
    }else{
        replace(index+1,builder);
    }
}

public List<String> letterCasePermutation(String S) {
    res=new ArrayList<>();
    if(S.length()==0){
        res.add("");
        return res;
    }
    StringBuilder builder=new StringBuilder(S);
    replace(0,builder);
    return res;
}
```

## 组合问题
### 77
[77 Combinations](https://leetcode.com/problems/combinations/description/)

* 问题：

给出两个整数n和k，求在1...n这n个数中取出k个数字的所有组合。

* 示例：

n=4，k=2

结果为[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]

* 解题：

<div align="center"><img src="pics//backtrack//backtrack_7.png" width="600"/></div>

```java
private List<List<Integer>> res;

//c存储已经找到的组合
//从start开始搜索新的元素
private void findCombination(int n,int k,int start,List<Integer> c){
    //递归结束条件，这里就是c中有k个元素
    if(k==c.size()){
        res.add(new ArrayList<>(c));
        return;
    }
    for(int i=start;i<=n;i++){
        c.add(i);
        findCombination(n,k,i+1,c);
        c.remove(c.size()-1);
    }
}

public List<List<Integer>> combine(int n, int k) {
    res=new ArrayList<>();
    if(n<=0 || k<=0 || k>n){
        return res;
    }
    List<Integer> c=new ArrayList<>();
    findCombination(n,k,1,c);
    return res;
}
```

### 78 
[78 Subsets](https://leetcode.com/problems/subsets/description/)
```java
/**
* 问题描述：
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
  
* 说明：解集不能包含重复的子集。
  
* 示例:
输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]
*/
private List<List<Integer>> res;

private void findSubset(int[] nums,int index,List<Integer> c){
    //这里不需要递归的结束条件
    //因为当index==nums.length之后，就会自动终止递归
    //为什么自己不递归？这样会导致解缺失的情况
    //if(index==nums.length){
    //    res.add(new ArrayList<>(p));
    //return;
    //}
    //结果：[[1, 2, 3], [1, 3], [2, 3], [3]]
    //因为每次递归对数组长度是没有要求的，加上条件后，每次只能获取定长的数据
    res.add(new ArrayList<>(c));
    for(int i=index;i<nums.length;i++){
        c.add(nums[i]);
        findSubset(nums,i+1,c);
        c.remove(c.size()-1);
    }
}

public List<List<Integer>> subsets(int[] nums) {
    res=new ArrayList<>();
    if(nums.length==0){
        return res;
    }
    List<Integer> c=new ArrayList<>();
    findSubset(nums,0,c);
    return res;
}
```

### 131
[131 Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/description/)
```java
/**
* 问题描述：
给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
返回 s 所有可能的分割方案。
  
* 示例:
输入: "aab"
输出:
[
["aa","b"],
["a","a","b"]
]
*/
private List<List<String>> res;
public List<List<String>> partition(String s) {
    res=new ArrayList<>();
    if(s.length()==0){
        return res;
    }
    List<String> p=new ArrayList<>();
    findPalindrome(s,0,p);
    return res;
}

private void findPalindrome(String s,int index,List<String> p){
    if(index==s.length()){
        res.add(new ArrayList<>(p));
        return;
    }
    for(int i=index;i<s.length();i++){
        // 字符串[index,i+1) ，一共有 i-index+1个元素
        String tmp=s.substring(index,i+1);
        if(isPalindrome(tmp)){
            p.add(tmp);
            findPalindrome(s,i+1,p);
            p.remove(p.size()-1);
        }
    }
}

//判断字符串是否是回文串
private boolean isPalindrome(String s){
    int start=0;
    int end=s.length()-1;
    while(start<end){
        if(s.charAt(start)!=s.charAt(end)){
            return false;
        }
        start++;
        end--;
    }
    return true;
}
```

## 回溯法解决组合问题的优化
### 77题的优化
[77 Combinations](https://leetcode.com/problems/combinations/description/)

使用剪枝法

<div align="center"><img src="pics//backtrack//backtrack_8.png" width="600"/></div>

```java
private void findCombination(int n,int k,int start,List<Integer> c){
    //递归结束条件，这里就是c中有k个元素
    if(k==c.size()){
        res.add(new ArrayList<>(c));
        return;
    }
    //c存储的是已经找到的组合
    //此时还剩下k-c.size()个空位，
    //[i...n]之间的元素最少要有k-c.size()个,即 n-i+1>=k-c.size()
    //得到 i<=n-(k-c.size())+1
    for(int i=start;i<=n-(k-c.size())+1;i++){
        c.add(i);
        findCombination(n,k,i+1,c);
        c.remove(c.size()-1);
    }
}
```

### 39
[39 Combination Sum](https://leetcode.com/problems/combination-sum/description/)
```java
/**
* 问题描述：
给定一个无重复元素的数组 candidates 和一个目标数 target ，
找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的数字可以无限制重复被选取。

* 说明：
所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 

* 示例：
示例 1:
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]

示例 2:
输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
*/
//思路：和 77题类似，但是要注意递归结束条件，由于可以使用重复元素，所以这里递归时i不需要+1
private List<List<Integer>> res;

private void findCombination(int[] candidates,int start,int target,List<Integer> p){
    if(target == 0){
        res.add(new ArrayList<>(p));
        return;
    }
    for(int i=start;i<candidates.length;i++){
        if(target>=candidates[i]){
            p.add(candidates[i]);
            findCombination(candidates,i,target-candidates[i],p);
            p.remove(p.size()-1);
        }
    }
    return;
}

public List<List<Integer>> combinationSum(int[] candidates, int target) {
    res = new ArrayList<>();
    if(candidates == null || candidates.length == 0){
        return res;
    }
    List<Integer> p = new ArrayList<>();
    findCombination(candidates,0,target,p);
    return res;
}
```

### 40 
[40 Combination Sum II](https://leetcode.com/problems/combination-sum-ii/description/)
```java
/**
* 思路：
给定一个数组 candidates 和一个目标数 target ，
找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用一次。
  
* 说明：
所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 
  
* 示例
示例 1:
输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
[1, 7],
[1, 2, 5],
[2, 6],
[1, 1, 6]
]

示例 2:
输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
[1,2,2],
[5]
]
*/
//思路：遇到重复元素，首先要想到排序

private List<List<Integer>> res;

private void findCombination2(int[] candidates,int start,int target,List<Integer> p){
    if(target == 0){
        res.add(new ArrayList<>(p));
        return;
    }
    for(int i=start;i<candidates.length;i++){
        if(i > start && candidates[i-1] == candidates[i]){
            continue;
        }
        if(target>=candidates[i]){
            p.add(candidates[i]);
            findCombination2(candidates,i+1,target-candidates[i],p);
            p.remove(p.size()-1);
        }
    }
}

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    res = new ArrayList<>();
    if(candidates == null || candidates.length == 0){
        return res;
    }
    Arrays.sort(candidates);
    List<Integer> p = new ArrayList<>();
    findCombination2(candidates,0,target,p);
    return res;
}
```

### 216
[216 Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/)
```java
/**
* 问题描述：

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，
并且每种组合中不存在重复的数字。

* 说明：
所有数字都是正整数。解集不能包含重复的组合。 

* 示例：
示例 1:
输入: k = 3, n = 7
输出: [[1,2,4]]

示例 2:
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
*/
//思路：注意递归结束条件是两个并列条件
private List<List<Integer>> res;

private void findCombination3(int k,int n,int start,List<Integer> p){
    if(p.size() == k && n==0){
        res.add(new ArrayList<>(p));
        return;
    }

    for(int i=start;i<=9;i++){
        if(n >= i){
            p.add(i);
            findCombination3(k,n-i,i+1,p);
            p.remove(p.size()-1);
        }
    }
    return;
}

public List<List<Integer>> combinationSum3(int k, int n) {
    res = new ArrayList<>();
    if(k>9 || n>45){
        return res;
    }
    List<Integer> p = new ArrayList<>();
    findCombination3(k,n,1,p);
    return res;
}
```

### 90 
[90 Subsets II](https://leetcode.com/problems/subsets-ii/description/)
```java
private List<List<Integer>> res;

private void findSubsets(int[] nums,int index,List<Integer> p){
    res.add(new ArrayList<>(p));
    for(int i=index;i<nums.length;i++){
        //剪枝去重复元素，对于搜索的任何一层决不能在本层出现重复，也就是说在相同index下不能出现重复的元素
        //(i>0 && nums[i-1]==nums[i]) 相邻的重复元素
        //i==index 表示在同一层
        if(i!=index && (i>0 && nums[i-1]==nums[i])){
            continue;
        }
        p.add(nums[i]);
        findSubsets(nums,i+1,p);
        p.remove(p.size()-1);
    }
}

public List<List<Integer>> subsetsWithDup(int[] nums) {
    res=new ArrayList<>();
    if(nums.length==0){
        return res;
    }
    Arrays.sort(nums);
    List<Integer> p=new ArrayList<>();
    findSubsets(nums,0,p);
    return res;
}
```

### 401
[401 Binary Watch](https://leetcode.com/problems/binary-watch/description/)
```java
public List<String> readBinaryWatch(int num) {
    List<String> res=new ArrayList<>();
    if(num<0){
        return res;
    }
    for(int h=0;h<12;h++){
        for(int m=0;m<60;m++){
            //统计h在二进制下“1”的数量
            //h=5 --> 转化为二进制(101)-->结果为2
            if(Integer.bitCount(h)+Integer.bitCount(m)==num){
                res.add(String.format("%d:%02d",h,m));
            }
        }
    }
    return res;
}
```
```java
//表示小时的灯
int[] hour={1,2,4,8};
//表示分钟的灯
int[] minute={1,2,4,8,16,32};

private List<String> res;

//num表示还需要点亮的LED数
//index表示所点的表示小时的LED的下标
private void solve(int num,int index,int[] watch){
    if(num==0){
        int h=0;
        int m=0;
        for(int i=0;i<hour.length;i++){
            h+=watch[i]*hour[i];
        }
        for(int i=0;i<minute.length;i++){
            m+=watch[i+4]*minute[i];
        }
        res.add(String.format("%d:%02d",h,m));
    }
    while(index<10){
        //选中index灯
        watch[index]=1;
        //条件取舍，对于hour>11 和 min>59的情况舍去
        if(!((watch[2]==1 && watch[3]==1)||(watch[6]==1 && watch[7]==1 && watch[8]==1 && watch[9]==1))){
            solve(num-1,index+1,watch);
        }
        watch[index]=0;
        index++;
    }
}

public List<String> readBinaryWatch(int num) {
    res=new ArrayList<>();
    //表示手表的10个LED灯，0:表示灯为开启，1表示灯开了
    int[] watch=new int[10];
    solve(num,0,watch);
    return res;
}
```

## 二维平面上的回溯法
### 79
[79 Word Search](https://leetcode.com/problems/word-search/description/)

* 问题：

给定一个二维平面的字母和一个单词，
看是否可以在这个二维平面上找到该单词。
其中找到这个单词的规则是，从一个字母出发，
可以横向或者纵向连接二维平面上的其他字母。
同一个位置的字母只能使用一次。

* 示例：

```java
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E'],
]

"ABCCED" --> true
"SEE" --> true
"ABCB" --> false
```

* 解题：

从该二维平面的[0,0]位置开始，想上，右，下，左四个方向查找字符串中指定位置的字符

<div align="center"><img src="pics//backtrack//backtrack_9.png" width="600"/></div>

向上，越界了；向右，刚好找到下一位置元素

<div align="center"><img src="pics//backtrack//backtrack_10.png" width="600"/></div>

依次进行

<div align="center"><img src="pics//backtrack//backtrack_11.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_12.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_13.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_14.png" width="600"/></div>

再从[0,1]位置开始...

递归形式为：

<div align="center"><img src="pics//backtrack//backtrack_15.png" width="600"/></div>

```java
//TODO：使用一个数组来表示要查找的方向,这是一个小技巧
private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

//因为要求在一次查找中字符只能出现一次
private boolean[][] visited;

//判断是否越界
private boolean inArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}
//m，n分别表示该维数组的行和列
private int m;
private int n;

//从board[startx][starty]开始寻找word[index...word.ength()]
private boolean searchBoard(char[][] board, String word,int index,int startx,int starty){
    if(index==word.length()-1){
        //递归到最后一个字符，看看从[startx,starty]位置开始，是否有该字符
        return board[startx][starty]==word.charAt(index);
    }
    if(board[startx][starty]==word.charAt(index)){
        visited[startx][starty]=true;
        //从[startx,starty]位置开始，向四个方向查找下一元素
        for(int i=0;i<4;i++){
            //TODO：对四个方向都进行查找
            int newx=startx+d[i][0];
            int newy=starty+d[i][1];
            if(inArea(newx,newy) && visited[newx][newy]==false){
                //从board[newx][newy]开始寻找word[index+1...word.ength()]
                if(searchBoard(board,word,index+1,newx,newy)){
                    return true;
                }
            }
        }
        visited[startx][starty]=false;
    }
    return false;
}

public boolean exist(char[][] board, String word) {
    m=board.length;
    assert m>0;
    n=board[0].length;
    visited=new boolean[m][n];
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(searchBoard(board,word,0,i,j)){
                return true;
            }
        }
    }
    return false;
}
```
## floodfill算法之一类经典问题
### 200*
[200 Number of Islands](https://leetcode.com/problems/number-of-islands/description/)

* 问题：

给定一个二维数组，只含有0和1两个字符。
其中1代表陆地，0代表水域。**横向和纵向**的陆地连接成岛屿，被水域分开。
问给出的地图中有多少岛屿？

* 示例：

<div align="center"><img src="pics//backtrack//backtrack_16.png" width="600"/></div>

* 解题：

floodfill算法描述：

从[0,0]位置开始进行标记，看[0,0,]位置的左、上、右、下相邻元素

<div align="center"><img src="pics//backtrack//backtrack_17.png" width="600"/></div>

一直进行深度优先搜索

<div align="center"><img src="pics//backtrack//backtrack_18.png" width="600"/></div>

到达某一端后，再递归回去

回退到箭头所值节点，在进行查找

<div align="center"><img src="pics//backtrack//backtrack_19.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_20.png" width="600"/></div>

依次进行...

<div align="center"><img src="pics//backtrack//backtrack_21.png" width="600"/></div>

```java
private int m;
private int n;

//用来标记是否是同一个岛屿
private boolean[][] visited;

//TODO:二维数组四个方向查找的小技巧
private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

private boolean isArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

//找到一个岛，就将这个岛标记
private void dfs(char[][] grid, int x, int y) {
    //[x,y]是陆地，并且标记为已经访问的了
    visited[x][y]=true;
    //向四个方向去扩散
    for(int i=0;i<4;i++){
        int newx=x+d[i][0];
        int newy=y+d[i][1];
        if(isArea(newx,newy)){
            //[newx,newy]合法
            if(grid[newx][newy]=='1' && visited[newx][newy]==false){
                //[newx,newy]位置陆地，并且未被标记，进行深度优先遍历
                //如果已经被标记了，则直接忽略
                ////找到一个岛，就将整个岛进行标记
                dfs(grid,newx,newy);
            }
        }
    }
}

public int numIslands(char[][] grid) {
    m=grid.length;
    if(m==0){
        return 0;
    }
    n=grid[0].length;
    visited=new boolean[m][n];
    int res=0;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            //有陆地，并且这块陆地未被标记，则就是一个新的岛屿
            if(grid[i][j]=='1' && visited[i][j]==false){
                res++;
                //使用floodfill算法来标记这个新岛屿岛屿
                dfs(grid,i,j);
            }
        }
    }
    return res;
}
```

### 130
[130 Surrounded Regions](https://leetcode.com/problems/surrounded-regions/descriptio

```java
/**
* 问题描述：
给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。
找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
  
* 示例:
  
X X X X
X O O X
X X O X
X O X X

运行你的函数后，矩阵变为：

X X X X
X X X X
X X X X
X O X X
解释:
被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。
任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。
如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
* */
//思路：将在边界上的 'O'全部标记为 true,将未被标记的'O'使用'X'代替

//写法一：深度遍历
private int m,n;
private boolean[][] visited; //标记边界上的 'O'

private int[][] d={
        {0,1},
        {0,-1},
        {-1,0},
        {1,0}
};

private boolean inArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

//只标记在边界上的'O'
private void dfs(char[][] board,int x,int y){
    visited[x][y] = true;
    for(int i=0;i<4;i++){
        int newX = x + d[i][0];
        int nexY = y + d[i][1];
        if(inArea(newX,nexY)){
            if(board[newX][nexY]=='O' && !visited[newX][nexY]){
                dfs(board,newX,nexY);
            }
        }
    }
}

public void solve(char[][] board) {
    m = board.length;
    if(m == 0){
        return;
    }
    n = board[0].length;
    visited = new boolean[m][n];

    //第一行和最后一行
    for(int j=0;j<n;j++){
        if(board[0][j]=='O' && !visited[0][j]){
            dfs(board,0,j);
        }
        if(board[m-1][j] =='O' && !visited[m-1][j]){
            dfs(board,m-1,j);
        }
    }
    //最右边
    for(int i=1;i<m-1;i++){
        if(board[i][0]=='O' && !visited[i][0]){
            dfs(board,i,0);
        }
        if(board[i][n-1]=='O' && !visited[i][n-1]){
            dfs(board,i,n-1);
        }
    }

    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(board[i][j] == 'O' && !visited[i][j]){
                board[i][j] = 'X';
            }
        }
    }

    /*for(int i=0;i<m;i++) {
        for (int j = 0; j < n; j++) {
            System.out.print(board[i][j]+" ");
        }
        System.out.println();
    }*/
}
```

```java
//写法二：广度遍历
private int m,n;
private boolean[][] visited; //标记边界上的 'O'

private int[][] d={
        {0,1},
        {0,-1},
        {-1,0},
        {1,0}
};

private boolean inArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

private class Coordinate{
    int x;
    int y;
    Coordinate(int x,int y){
        this.x = x;
        this.y = y;
    }
}
//只标记在边界上的'O'
private void bfs(char[][] board,int x,int y){
    visited[x][y] = true;
    Queue<Coordinate> queue = new LinkedList<>();
    queue.add(new Coordinate(x,y));

    while (!queue.isEmpty()){
        x = queue.peek().x;
        y = queue.peek().y;
        queue.poll();
        for(int i=0;i<4;i++){
            int newX = x + d[i][0];
            int nexY = y + d[i][1];
            if(inArea(newX,nexY)){
                if(board[newX][nexY]=='O' && !visited[newX][nexY]){
                    queue.add(new Coordinate(newX,nexY));
                    //TODO:标记
                    visited[newX][nexY] = true;
                }
            }
        }
    }
}

public void solve(char[][] board) {
    m = board.length;
    if(m == 0){
        return;
    }
    n = board[0].length;
    visited = new boolean[m][n];

    //第一行和最后一行
    for(int j=0;j<n;j++){
        if(board[0][j]=='O' && !visited[0][j]){
            bfs(board,0,j);
        }
        if(board[m-1][j] =='O' && !visited[m-1][j]){
            bfs(board,m-1,j);
        }
    }
    //最右边
    for(int i=1;i<m-1;i++){
        if(board[i][0]=='O' && !visited[i][0]){
            bfs(board,i,0);
        }
        if(board[i][n-1]=='O' && !visited[i][n-1]){
            bfs(board,i,n-1);
        }
    }

    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(board[i][j] == 'O' && !visited[i][j]){
                board[i][j] = 'X';
            }
        }
    }

    /*for(int i=0;i<m;i++) {
        for (int j = 0; j < n; j++) {
            System.out.print(board[i][j]+" ");
        }
        System.out.println();
    }*/
}
```

### 417
[417 Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/)
```java
/**
* 问题描述：
给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。
“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。
规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。
请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

* 提示：
输出坐标的顺序不重要
m 和 n 都小于150


* 示例：
给定下面的 5x5 矩阵:

太平洋 ~   ~   ~   ~   ~ 
     ~  1   2   2   3  (5) *
     ~  3   2   3  (4) (4) *
     ~  2   4  (5)  3   1  *
     ~ (6) (7)  1   4   5  *
     ~ (5)  1   1   2   4  *
        *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
*/
//思路: 与130题类似，分别从太平洋沿岸和大西洋沿岸进行标记

private int m,n;
//标记太平洋沿岸
private boolean[][] pacific;
//标记大西洋沿岸
private boolean[][] atlantic;

private int[][] d = {
        {0,1},
        {0,-1},
        {-1,0},
        {1,0}
};

private boolean inArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

//从太平洋沿岸和大西洋沿岸进行标记 --> 沿岸地势一定比较低
private void dfs(int[][] matrix,boolean[][] visited,int x,int y){
    visited[x][y] = true;
    for(int i=0;i<4;i++){
        int newX = x + d[i][0];
        int newY = y + d[i][1];
        if(inArea(newX,newY)){
            if(matrix[newX][newY] >= matrix[x][y] && !visited[newX][newY]){
                dfs(matrix,visited,newX,newY);
            }
        }
    }
}

public List<int[]> pacificAtlantic(int[][] matrix) {
    m = matrix.length;
    List<int[]> res = new ArrayList<>();
    if(m==0){
        return res;
    }
    n = matrix[0].length;
    pacific = new boolean[m][n];
    atlantic = new boolean[m][n];

    //从太平洋沿岸标记
    for(int j=0;j<n;j++){
       dfs(matrix,pacific,0,j);
    }
    for(int i=1;i<m;i++){
        dfs(matrix,pacific,i,0);
    }

    //从大西洋沿岸标记
    for(int j=0;j<n;j++){
        dfs(matrix,atlantic,m-1,j);
    }
    for(int i=0;i<m-1;i++){
        dfs(matrix,atlantic,i,n-1);
    }

    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(pacific[i][j] && atlantic[i][j]){
                res.add(new int[]{i,j});
            }
        }
    }
    return res;
}
```

### 695
[695 Max Area of Island](https://leetcode.com/problems/max-area-of-island/description/)
```java
private int m;
private int n;

//用来标记是否是同一个岛屿
private boolean[][] visited;

//TODO:二维数组四个方向查找的小技巧
private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

private boolean isArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

//找到一个岛，就将这个岛标记
//返回的值就是[x,y]所在岛屿的面积
private int dfs(int[][] grid, int x, int y) {
    if(grid[x][y] == 0){
        return 0;
    }

    //[x,y]是陆地，并且标记为已经访问的了
    visited[x][y]=true;

    int area=1;

    //向四个方向去扩散
    for(int i=0;i<4;i++){
        int newx=x+d[i][0];
        int newy=y+d[i][1];
        if(isArea(newx,newy)){
            //[newx,newy]合法
            if(grid[newx][newy]==1 && visited[newx][newy]==false){
                //[newx,newy]位置陆地，并且未被标记，进行深度优先遍历
                //如果已经被标记了，则直接忽略
                //找到一个岛，就将整个岛进行标记
                area+=dfs(grid,newx,newy);
            }
        }
    }
    return area;
}

public int maxAreaOfIsland(int[][] grid) {
    m=grid.length;
    if(m==0){
        return 0;
    }
    n=grid[0].length;
    visited=new boolean[m][n];
    int res=0;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            //有陆地，并且这块陆地未被标记，则就是一个新的岛屿
            if(grid[i][j]==1 && visited[i][j]==false){
                //使用floodfill算法来标记这个新岛屿岛屿
                res=Math.max(res,dfs(grid,i,j));
            }
        }
    }
    return res;
}
```

### 733
[733 Flood Fill](https://leetcode.com/problems/flood-fill/description/)
```java
private int m;
private int n;

//用来标记是否是同一中颜色
private boolean[][] visited;

//TODO:二维数组四个方向查找的小技巧
private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

private boolean isArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

//对颜色进行标记
private void dfs(int[][] image, int color,int newColor,int x, int y) {
    visited[x][y]=true;
    image[x][y]=newColor;
    //向四个方向去扩散
    for(int i=0;i<4;i++){
        int newx=x+d[i][0];
        int newy=y+d[i][1];
        if(isArea(newx,newy)==true){
            //[newx,newy]合法
            if(image[newx][newy]==color && visited[newx][newy]==false){
                //[newx,newy]，并且未被标记，进行深度优先遍历
                image[newx][newy]=newColor;
                dfs(image,color,newColor,newx,newy);
            }
        }
    }
}

public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
    m=image.length;
    if(m==0){
        return image;
    }
    n=image[0].length;
    visited=new boolean[m][n];
    int color=image[sr][sc];
    dfs(image,color,newColor,sr,sc);
    return image;
}
```

## 回溯法是经典人工智能的基础
### 51
[51 N-Queens](https://leetcode.com/problems/n-queens/description/)

* 问题：

<div align="center"><img src="pics//backtrack//backtrack_22.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_23.png" width="600"/></div>

* 解题：

<div align="center"><img src="pics//backtrack//backtrack_24.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_25.png" width="600"/></div>

判断对角线不合法的情况：

(1)竖向：col[i]表示第i列被占用

(2)对角线1：dai1[i]表示第i对角线被1占用

(3)对角线2：dai2[i]表示第i对角线被2占用

<div align="center"><img src="pics//backtrack//backtrack_26.png" width="600"/></div>
<div align="center"><img src="pics//backtrack//backtrack_27.png" width="600"/></div>

```java
private List<List<String>> res;

//用于判断是否在同一竖线上，因为index表示行数，是变化的，所以不用判断是否在相同行
private boolean col[];
//判断是是否在1类对角线上
private boolean dia1[];
//判断是是否在2类对角线上
private boolean dia2[];

//在 n*n 棋盘的index行上放皇后
//row用于存储在index行能够放皇后的位置
private void putQueuen(int n,int index,List<Integer> row){
    if(index==n){
        //generateBoard(n,row)用于产生棋盘
        res.add(generateBoard(n,row));
        return;
    }
    for(int j=0;j<n;j++){
        //TODO:对角线的表示
        // 1类对角线 i+j = 同一元素 （i，j为二维数组的下标）
        // 2类对角线 i-j+n-1 = 同一元素
        if(col[j]==false && dia1[index+j]==false && dia2[index-j+n-1]==false){
            row.add(j);
            col[j]=true;
            dia1[index+j]=true;
            dia2[index-j+n-1]=true;
            putQueuen(n,index+1,row);
            dia2[index-j+n-1]=false;
            dia1[index+j]=false;
            col[j]=false;
            row.remove(row.size()-1);
        }
    }
    return;
}

//row用于存储index行能够放皇后的位置
private List<String> generateBoard(int n,List<Integer> row){
    char[][] board=new char[n][n];
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            board[i][j]='.';
        }
    }
    for(int i=0;i<n;i++){
        board[i][row.get(i)]='Q';
    }
    List<String> list=new ArrayList<>();
    for(int i=0;i<n;i++){
        list.add(new String(board[i]));
    }
    return list;
}

public List<List<String>> solveNQueens(int n) {
    res=new ArrayList<>();
    if(n==0){
        return res;
    }
    col=new boolean[n];
    dia1=new boolean[2*n-1];
    dia2=new boolean[2*n-1];
    List<Integer> row=new ArrayList<>();
    putQueuen(n,0,row);
    return res;
}
```

### 52
[52 N-Queens II](https://leetcode.com/problems/n-queens-ii/description/)
```java
private int num=0;

private boolean[] col;
private boolean[] dia1;
private boolean[] dia2;

//在 n*n 棋盘的index行上放皇后
//row用于存储在index行能够放皇后的位置
private void putQuenen(int n,int index,List<Integer> row){
    if(index==n){
        num++;
        return;
    }
    for(int j=0;j<n;j++){
        if(col[j]==false && dia1[index+j]==false && dia2[index-j+n-1]==false){
            row.add(j);
            col[j]=true;
            dia1[index+j]=true;
            dia2[index-j+n-1]=true;
            putQuenen(n,index+1,row);
            dia2[index-j+n-1]=false;
            dia1[index+j]=false;
            col[j]=false;
            row.remove(row.size()-1);
        }
    }
}

public int totalNQueens(int n) {
    col=new boolean[n];
    dia1=new boolean[2*n-1];
    dia2=new boolean[2*n-1];
    List<Integer> row=new ArrayList<>();
    putQuenen(n,0,row);
    return num;
}
```

### 37
[37 Sudoku Solver](https://leetcode.com/problems/sudoku-solver/description/)

**数独（Sudoku）** 是一款大众喜爱的数字逻辑游戏。
玩家需要根据9X9盘面上的已知数字，推算出所有剩余空格的数字，并且满足
每一行、每一列、每一个**粗线宫内的数字均含1-9**，并且不重复。

```java
private boolean canPutNum(char[][] board,int pos,
                    boolean[][] row, boolean[][] col, boolean[][] block){
    if(pos==81){
        return true;
    }
    //next位置为pos位置后下一个要填写的位置
    int next = pos + 1;
    for(; next < 81; next ++){
        if(board[next / 9][next % 9] == '.'){
            break;
        }
    }

    //pos的位置在表格中是[x,y]
    int x = pos / 9;
    int y = pos % 9;

    //pos位置要填写的是数字[1...9]
    for(int i = 1; i <= 9; i ++){
        if(row[x][i]==false && col[y][i]==false && block[x/3*3+y/3][i]==false){
            row[x][i]=true;
            col[y][i]=true;
            block[x/3*3+y/3][i]=true;
            board[x][y]=(char)(i+'0');
            if(canPutNum(board,next,row,col,block)){
                return true;
            }
            block[x/3*3+y/3][i]=false;
            col[y][i]=false;
            row[x][i]=false;
            board[x][y]='.';
        }
    }
    return false;
}

public void solveSudoku(char[][] board) {
    boolean[][] row = new boolean[9][10];
    boolean[][] col = new boolean[9][10];
    boolean[][] block = new boolean[9][10];

    //对于表格中已经有的数据，设置成true
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                int num = board[i][j] - '0';
                row[i][num] = true;
                col[j][num] = true;
                block[i / 3 * 3 + j / 3][num] = true;
            }
        }
    }
    for(int i=0;i<81;i++){
        if(board[i/9][i%9]=='.'){
            if(canPutNum(board,i,row,col,block)==false){
                continue;
            }
        }
    }
}
```

## 更多回溯问题
### 473 
[473 Matchsticks to Square](https://leetcode.com/problems/matchsticks-to-square/description/)
```java
/**
 * 思路：
 * 建立一个长度为4的数组sums来保四条的长度和，我们希望每条边都等于target=sum/4。
 * 所有火柴总长度必须是4的倍数，否则不能构成正方形。
 * 每根火柴必须用到，这里通过递归深度优先的方法逐个遍历所有火柴，
 * 依次将其加入到四条边上之后进行下一层遍历，
 * 如果最终四条边长度都达到边长长度则返回true，否则遍历完所有情况后返回false。
 */
public boolean makesquare(int[] nums) {
    if (nums == null || nums.length < 4) {
        return false;
    }
    int sum=0;
    for(int num:nums){
        sum+=num;
    }
    if(sum%4!=0){
        return false;
    }
    int[] sums=new int[4];
    int target=sum/4;
    return canPutMatchSticks(nums,sums,0,target);
}
/**
 * @param nums 火柴长度数组
 * @param sums 存储四条边的长度之和
 * @param step 每次放一根火柴棒的步数
 * @param target 目标正方形的边长
 */
private boolean canPutMatchSticks(int[] nums,int[] sums,int step,int target){
    if(step==nums.length){
        if(sums[0]==target && sums[1]==target &&
                sums[2]==target && sums[3]==target){
            return true;
        }else{
            return false;
        }
    }
    for(int i=0;i<4;i++){
        //sum[i]表示该正方形某一边的长度 nums[step]第step步放入火柴
        //sums[i]+nums[step] 就表示在step步将火柴放入长度为sum[i]的边上
        if(sums[i]+nums[step]>target){
            continue;
        }
        sums[i]+=nums[step];
        if(canPutMatchSticks(nums,sums,step+1,target)){
            return true;
        }
        sums[i]-=nums[step];
    }
    return false;
}
```

* 改进版: 使用剪枝，改进canPutMatchSticks()方法
```java
/**
 * @param nums 火柴长度数组
 * @param sums 存储四条边的长度之和
 * @param step 每次放一根火柴棒的步数
 * @param target 目标正方形的边长
 */
private boolean canPutMatchSticks(int[] nums,int[] sums,int step,int target){
    if(step==nums.length){
        return true;
    }
    for(int i=0;i<4;i++){
        //sum[i]表示该正方形某一边的长度 nums[step]第step步放入火柴
        //sums[i]+nums[step] 就表示在step步将火柴放入长度为sum[i]的边上
        if(sums[i]+nums[step]>target) {
            continue;
        }
        if(step<4 && i>step){
            break;
        }
        sums[i]+=nums[step];
        if(canPutMatchSticks(nums,sums,step+1,target)){
            return true;
        }
        sums[i]-=nums[step];
    }
    return false;
}
```

### 698
[698 Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/)
```java
public boolean canPartitionKSubsets(int[] nums, int k) {
    if(nums==null || nums.length<k){
        return false;
    }
    int sum=0;
    for(int num:nums){
        sum+=num;
    }
    if(sum%k!=0){
        return false;
    }
    int[] sums=new int[k];
    int target=sum/k;
    return canPartition(nums,sums,k,0,target);
}

private boolean canPartition(int[] nums,int[] sums,int k,int index,int target){
    if(index==nums.length){
        return true;
    }
    for(int i=0;i<k;i++){
        if(sums[i]+nums[index]>target){
            continue;
        }
        if(index<k && i>index){
            break;
        }
        sums[i]+=nums[index];
        if(canPartition(nums,sums,k,index+1,target)){
            return true;
        }
        sums[i]-=nums[index];
    }
    return false;
}
```

### 22
[22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

```java
/**
* 问题描述：
给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

例如，给出 n = 3，生成结果为：

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
*/
//思路一：暴力解法，但是会超出时间限制
private char[] chs;
private List<String> res;
private boolean[] visited;

public List<String> generateParenthesis(int n) {
    res = new ArrayList<>();
    if( n<=0){
        return res;
    }
    chs = new char[2*n];
    for(int i=0;i<n;i++){
        chs[i] = '(';
    }
    for(int i=n;i<2*n;i++){
        chs[i] = ')';
    }
    visited = new boolean[2*n];
    StringBuilder builder = new StringBuilder();
    generateParenthesis(chs,0,builder);

    HashSet<String> set = new HashSet<>(res);
    res.clear();
    res.addAll(set);
    return res;
}

private void generateParenthesis(char[] chs,int index,StringBuilder builder){
    if(index == chs.length && isValid(builder.toString())){
        System.out.println(builder);
        res.add(builder.toString());
        return;
    }
    for(int i=0;i<chs.length;i++){
        if(visited[i] == false){
            builder.append(chs[i]);
            visited[i] = true;
            generateParenthesis(chs,index+1,builder);
            //System.out.println(builder.toString());
            builder.deleteCharAt(builder.length()-1);
            visited[i] = false;
        }
    }
    return;
}

//判断该字符串是否是括号匹配的字符串
private boolean isValid(String s){
    Stack<Character> stack = new Stack<>();
    for(int i=0;i<s.length();i++){
        char c = s.charAt(i);
        if(c =='('){
            stack.push(c);
        }else{ // c==')'
            if(stack.isEmpty()){
                return false;
            }
            //弹出栈顶元素
            stack.pop();
        }
    }
    return stack.isEmpty();
}
```

```java
//思路二：
//递归终止条件：如果左右括号都没了，那么把解返回解空间。
//选择条件1：如果左括号还有，那么就递归。
//递归关系： 如果左括号还有，那么就用掉一个左括号（字符串+“（”，函数中left-1）
//选择条件2：如果左括号剩余数量小于右括号剩余数量，那么就递归。
//递归关系： 用掉一个右括号

private List<String> res;

public List<String> generateParenthesis(int n) {
    res = new ArrayList<>();
    if(n <= 0){
        return res;
    }
    StringBuilder builder = new StringBuilder();
    generateParenthesis(n,n,builder);
    return res;
}

private void generateParenthesis(int left,int right,StringBuilder builder){
    if(left == 0 && right==0){
        System.out.println("builder:"+builder.toString());
        res.add(builder.toString());
        return;
    }
    if(left>0){
        builder.append('(');
        generateParenthesis(left-1,right,builder);
        System.out.println("[left="+left+",right="+right+"]\tafter add ( :"+builder.toString());
        builder.deleteCharAt(builder.length()-1);
    }
    if(left<right){
        builder.append(')');
        generateParenthesis(left,right-1,builder);
        System.out.println("[left="+left+",right="+right+"]\tafter add ) :"+builder.toString());
        builder.deleteCharAt(builder.length()-1);
    }
    return;
}
```

## 其他递归问题